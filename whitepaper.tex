\documentclass[twocolumn]{article}

\begin{document}
\frenchspacing

\title{Sia: Simple Decentralized Storage}

\author{
{\rm David Vorick}\\
Nebulous Inc.\\
david@nebulouslabs.com
\and
{\rm Luke Champine}\\
Nebulous Inc.\\
luke@nebulouslabs.com
}

\maketitle

\subsection*{Abstract}
Sia is a blockchain-based cryptosystem that enables decentralized file storage.
This paper serves as both a high level overview and as a specification.

\section{Introduction}
We wish to create a decentralized cloud storage platform that is more powerful than the existing centralized storage platforms.
We use smart contracts and decentralized consensus as the foundation for our platform.
We start with a system very similar to Bitcoin and add a self-enforcing contract that allows hosts to accept compensation for storing a file if they can regularly submit proof that they are storing the file.
The network automatically creates proof of storage challenges.

Building on top of Bitcoin directly will not work because we need self-enforcing contracts for hosting files, something that is beyond Bitcoin's flexibility.
We have considered being a sidechain, but are not convinced that a sidechain offers sufficient security.
We have chosen to make our own altcoin instead of using another altcoin such as Ethereum or Storj because we have not been sufficiently convinced that other altcoins are taking a secure approach.
We plan on having Sia be merge-mined with Bitcoin to minimize dilution of mining power within the cryptocurrency ecosystem.

\section{General Structure}
% Add references to Bitcoin here?
% Add references to Bitcoin Whitepaper + Developers Guide? Another decent explanation of Bitcoin?

The general rules for mining blocks, handling orphan blocks, etc. on Sia will be the same as Bitcoin.
Sia's primary departure from Bitcoin lies in its transactions.
Bitcoin uses a scripting system to enable a range of transaction types, such as pay-to-public-key-hash and pay-to-script-hash.
Sia opts instead to use an M-N multi-signature hash scheme for all transactions.
This reduces complexity and attack surface.

Sia further extends multisig transactions to enable file storage on the network.
Two extensions are needed to accomplish this: file contracts and storage proofs.
File contracts declare the intention of a host to store a file with a certain size and hash.
They specify that a host must periodically prove that they are still storing the file.
Hosts accomplish this by submiting storage proof transactions to the network.

Backing each file contract is a contract fund.
If a storage proof is valid, funds are sent to the host.
If the proof is invalid (or missing), funds are instead sent to the client, in the manner of a refund.

\section{Transactions}
Each transaction:
\begin{enumerate}
	\item Version
	\item Arbitrary Data
	\item Input List
	\item Output List
	\item A File Contract
	\item A Storage Proof
	\item Transaction Signatures
\end{enumerate}

The difference between the inputs and outputs is given as a transaction fee to the miner.

The arbitrary data is limited to 1kb, and is useful for hosts or clients making machine-readable announcements.

The output list, the file contract, and the storage proof are all optional fields.

\subsection{Inputs}
Each Input:
\begin{enumerate}
	\item Previous Output ID
	\item Previous Output Spend Conditions
\end{enumerate}

\subsection{Outputs}
Each Output:
\begin{enumerate}
	\item Amount Sent to Output
	\item Hash of Output Spend Conditions.
\end{enumerate}

Outputs are identified by id.
The output id is derived from the transaction that the output appeared in.
The output id is derived by taking H(id of input 0 $||$ output index).

\subsection{Spend Conditions}
\begin{enumerate}
	\item Timelock
	\item Number of Signatures Required
	\item Number of Valid Public Keys
	\item Each Valid Public Key
\end{enumerate}

The timelock prevents an output from being spent until a certain time.

The number of signatures and public keys creates an m-of-n multisig, where m is the number of signatures required, and n is the number of public keys provided.

\subsection{Signatures}
Each Signature:
\begin{enumerate}
	\item Timelock
	\item Input ID
	\item Signature Array
	\item Actual Signature
\end{enumerate}

The timelock prevents a signature from being valid until a certain time.
The signature array indicates what is being signed, which optionally allows for certain fields to be malleable.
It is a 32 bit array, one bit for each input and one bit for each output, plus one bit for the transaction type, and one for the transaction type field.

The input id must be an input in the transaction.

The signature covers:
\begin{enumerate}
	\item The Signature Timelock
	\item The Signature Input ID
	\item The Signature Signature Array
	\item Every field specified by the signature array.
\end{enumerate}

The signature array can specify the following items:
\begin{enumerate}
	\item The Transaction Version
	\item The Arbitrary Data
	\item The File Contract
	\item The Storage Proof
	\item Any combination of inputs, including all or none of them.
	\item Any combination of outputs, including all or none of them.
\end{enumerate}

Each signature corresponds to a single public key.
Inputs that require multiple signatures will have multiple signatures listed in the signatures section, each with a potentially different set of fields that are signed.

\section{File Contracts}
A file contract is an agreement between a host and an uploader that the host will store a file.
The file is split into 64 byte segments, and a merkle tree is created from these segments.
The root hash of the merkle tree is stored, along with the quantity of 64 byte blocks contained in the original file.

The type field for a file contract contains:
\begin{enumerate}
	\item Root hash of the merkle tree created from the file.
	\item The number of leaves in the merkle tree.
	\item A challenge frequency.
	\item A reward for successfully completing a proof, along with the recipient.
	\item A reward for a missed proof, along with the recipient.
	\item Number of consecutive missed proofs to terminate a contract, along with a recipient for all remaining input coins. (Unsuccessful termination)
	\item Total duration of contract, along with a recipeint for all remaining input coins in the event of finishing the duration without triggering a termination. (Successful termination)
\end{enumerate}

The challenge frequency indicated how frequently a challenge will be issued to a host for a proof of storage.
If the frequency is 20 blocks, then a challenge will be issued once every 20 blocks and the host will have 20 blocks to satisfy the challenge.

The rewards for completed proofs and missed proofs create a new transaction output belonging to the recipient specified in the contract.
The recipient will be a hahs of the output spend conditions for the new output.
The output id is defined by H(first valid input id of transaction $||$ reward type $||$ reward index)
The reward type is one of 4 values: successful proof, missed proof, sucessful termination, unsuccessful termination.
The index is the number of previous times an output has been created by this reward type for this contract.
For example, the first successful proof will have an index of 0, the second will have an index of 1.
Terminations will always have an index of 0, as the contract can only terminate once.

The final termination type is 'early termination', and is what happens if a contract runs out of funds before either other termination happens.

The contract id is defined by the hash of the transaction announcing the contract.

The contract must be funded by output 0, which must specify a null recipient. (All 0's for the hash of the output spend conditions)
A transaction with a contract that has a non-zero output 0 is invalid.
% This section needs help.

\section{Proof of Storage}
Each proof of storage transaction targets a specific file.
A storage proof does not need to have any inputs or outputs.

A storage proof has:
\begin{enumerate}
	\item A contract id.
	\item The proof of storage.
\end{enumerate}

\subsection{Storage Challenges}
Each contract has a challenge frequency, requiring a storage proof every N blocks.
These windows are strictly defined, with the first window $W_0$ starting at block X, the second window $W_1$ starting at block X+N, and so on.
The challenge requires a random number as a seed.
The random number for window $W_i$ is derived from the hash of block $X-1 + i*N$.

Using the random seed, one of the 64 bytes blocks from the original file is chosen.
In one of the blocks covered by $W_i$ the host must submit a proof that they have the selected block.
This is done by providing the 64 byte block, and then supplying the set of hashes that build each unknown branch of the merkle tree.
The network, knowing both the root hash and index of the 64 byte block, is able to take the set of hashes and determine how to build the tree, then verifying that the root matches.

If the host is consistently able to demonstrate possession of a random 64 byte block, then the host is very likely storing the whole file.
A host storing only 50\% of the file will be unable to complete approximately 50\% of the proofs.

\subsection{Random Number Generation}
The random number generator is subject to manipulation from block withholding attakcs.
The random number is derived from a specific block, meaning that an attacker has only one chance to manipulate the random number for a particular challenge.
The probability that an attacker will have the ability to manipulate the random number is equivalent to the probability that the attacker finds the block which generates the random number.
Furthermore, withholding a block to manipulate the random number will cost the attacker the block reward.

If an attacker is able to mine 50\% of the blocks, then a full 50\% of the challenges will still be random.
An attacker storing only 50\% of a file will be able to complete the storage proof 75\% of the time, even using manipulation.

Clients can protect themselves against random number attacks by having very large penalties for missing proofs.
By having large windows and severe penalties, a financially incentivized attacker with less than 50\% hashing power will not have reason to perform manipulation attacks.

\subsection{Closed Window Attacks}
Hosts can only complete a proof of storage if they can get a transaction with the storage proof into the blockchain.
Miners could maliciously exclude storage proofs from blocks, depriving themselves of transactions fees but forcing a penalty the hosts.
We call this a 'closed window' attack, because though the host has created the storage proof within the required window of time, they were unable to get the proof onto the blockchain.

The defense for this is having large windows, and assuming that at least one miner will be content submitting the storage proof in a block in return for a transaction fee.
Because hosts consent to all file contracts, the host is able to reject any contract that they feel leaves them vulnerable to a closed window attack.

\section{Arbitrary Transaction Data}
The arbitrary data provides hosts and clients a decentralized way to organize themselves.
Sia will likely be released with some standards for hosts announcing themselves to the world using the arbitrary data field.
These standards will also include ways for hosts to associate themselves with certain files, so that the hosts can build up a reputation that's auditable on the decentralized ledger.
Lightweight nodes will not need to store the arbitrary data.

The arbitrary data is likely to be valuable to clients, which means clients may be willing to pay for access to the data.
If too few miners are storing the full blockchain, clients can start rewarding miners who provide access to the arbitrary data fields.
This creates incentives.

The service provided by the arbitrary data fields could also be provided by a centralized service such as a forum or tracker.

\section{Being a Host}
As a host, you would make an announcement using a host announcement and follow some standard for organizing the announcement.
This would contain information about how to contact you, your typical price and penaltys, and some cryptographic indication of which files you are already storing.

Clients would then contact you, requesting you hold onto files.
You agree to hold onto files, but only after they have given you the whole file.

You use microchannel payments to charge the clients for downloading the file.

As a host, you are protected against files you don't want because you don't have to agree to store anything.

\section{Being an Uploader}
You break the file into a bunch of erasure coded pieces, using M of N erasure coding.
You encrypt the N pieces individually and upload them each to a different host.

You find hosts by scanning the host announcements and having some protocol for reading them.
You create a pool of hosts that fit your uploading criteria, and contact them at random weighted according to how much you trust them.
The randomness protects you from malicious hosts and network instability.

You upload the file to each of the hosts and they post a file contract agreeing to store them.
You check in on the file every few months and do any repairs needed if hosts go offline.

You use microchannel payments to negotiate downloads.
You are protected against hosts holding your data hostage because you can just go to other hosts who are not holding it hostage.
When data is available in many places, the places individually do not have much power over you.

\section{Uptime Incentives}
The storage proofs contain no provisions that require constant uptime.
There are also no provisions that require hosts to upload files to clients.

However, hosts and clients can create micropayment channels to facilitate downloads.
The client agrees to pay some worthwhile fee to the host every time they download the file.
If the host is not online, the client will pay one of the redundant hosts that are online.

Hosts are then incentivized to be online all the time, so that they can collect the bandwidth fees from clients.
If clients behaviorally pay hosts well, then hosts are more heavily incentivized to be online all the time.
Clients can also more heavily reward greater throughput and lower latency.
Clients could even do random "checkups" that pay hosts some nontrivial reward simply for being online.

Simplified, uptime incentives do not rely on the structure of the protocol, they rely on the behavior of clients.

% \section{Micropayment Channels}
% Actually this could be a subsection somewhere else.
% Reference important stuff here.
%
% \subsection{Establishing a Contract}
% Give at least one method for creating a file contract in a trust free environment
% maybe find a paper.

% \section{Sianotes}
% \subsection{Taxing Contracts}
% \subsection{Avoiding Taxes}
% \subsection{Sianotes outputs}

% \section{Economics of Sia}
% \subsection{Sianotes, income, no premining}
% \subsection{Permanent inflation}
% \subsection{Locking Coins Down}

\section{Under Consideration}
\subsection{File Contract Penalty Scaling}
The idea is to add a scaling factor to the file contract payouts to reward/punish consistent behavior.
For example, you could have the penalty for missing a storage proof double every time that the penalty is missed.
Or, you could have the reward for making a storage proof increase every time a storage proof is submitted.

We are unclear on what might be the exact best way to accomplish this.

\subsection{Reduced Block Time}
We are considering 6 minutes.
Merchents would still be advised to wait for 1 hour of work; 10 confirmations.
% Reference a paper here discussing difficulty, variance, propagation, etc.
% Go into depth on the specific risks and rewards from adjusting the difficulty.

\subsection{Difficulty Adjustments Every Block}
Difficulty adjustments every block. (note - dishonest difficulty attack - ask wizards if there is a fix)
Max adjustments of 1.0005x per block, corresponding to a max change of 5.3x every 2 weeks, compared to Bitcoin's clamp at 4x every 2 weeks.
% reference paper here...

\subsection{Subsidy Adjustments Every Block}
Block subsidy adjustments every block.
Inflation initially be very high, around 25\% in year two.
By year 4, inflation will taper to 2.5\% anually, and it will stay at that rate permenently.
% reference paper here, potentially talk about economics... or put that in another section?

\subsection{Max Block Size Adjustment}
Max block size will be initially set at 256kb and increased by 256kb every 3 months for 2 years.
Then it will increase by 25\% anually.
% reference something here

\subsection{Committing to State}
One thing that could allow for substantially lighter weight clients is if the miners committed to the current state of the network, instead of just to the new transactions.
This would mean creating a structure for a database and hashing it.
The database could be as simple as a series of structs, but there is a lot to consider when building this.
We do not plan to have this in the beta, but are considering it for the 1.0.

\subsection{Variance Enforced Merge Mining}
Bitcoin enforces a number of leading 0s on a winning block.
Sia could enforce something like a single leading 1, followed by a bunch of leading 0s.
This creates the property that no hash is ever valid for both Bitcoin and Sia.

The value to this is that the number of payouts a miner gets from finding blocks goes up.
The total payout is still the same, but the number of payouts increases by the number of blocks that would have been valid for both.
A block that solves the coin with the highest difficulty will always be valid for both blockchains.
(I need to read more about merge mining before I publish this section)

\subsection{Stale Mining}
Right now there are a decent amount of ways in Bitcoin to induce stale mining.
Block witholding attacks for example.
Awkward block timings for example (put the block on the edge of acceptible time, so that half the network rejects it).

\subsection{Merkling Transactions}
The idea is to have each transaction hashed in a way that's similar to a merkle tree, not for efficiency of proofs but rather so that certain details of a transaction can be revealed (such as a timelock) without revealing all of the details of the transaction.

\subsection{Proof of Storage on Arbitrary Data}
There's a bunch of arbitrary data in the blockchain and not a whole lot of incentive for hosts to hang onto it.
Requiring a proof of storage may fix this.
Or it may just be good enough for new clients to expect to get the data when they download the blockchain.

It's only a problem if people start accepting blocks even when they don't know what the arbitrary data is.

\subsection{Single Use Multisig Trnasactions}
The idea is that you have multiple signatures on a multisig, but you can only use each one once.
This allows you to collect payments from the same address many times without needing to reuse a signature.

\section{Conclusion}
Sia is a minimalist financial protocol designed to enable decentralized storage.

%\onecolumn
%\begin{bibliography}{1}

%\bibitem{}

%\end{bibliography}

\end{document}
