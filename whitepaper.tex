\documentclass[twocolumn]{article}
\usepackage{amsmath}

\begin{document}
\frenchspacing

\title{Sia: Simple Decentralized Storage - Draft}

\author{
{\rm David Vorick}\\
Nebulous Inc.\\
david@nebulouslabs.com
\and
{\rm Luke Champine}\\
Nebulous Inc.\\
luke@nebulouslabs.com
}

\maketitle

\subsection*{Abstract}
Sia is a platform for decentralized storage.
Storage providers agree produce regular proofs of storage in return for compensation.
Failure to provide storage proofs results in financial penalty.

Sia is a Bitcoin-based POW altchain that has added support for a specific type of storage contract.
Sia will initally be implemented as an altcoin, and later financially connected to Bitcoin through a two way peg.

\section{Introduction}
We wish to create a decentralized cloud storage platform that has the ability to compete with existing solutions for cloud storage, both at the p2p level and the enterprise level.
We wish to achieve the following goals:
\begin{itemize}
	\item Anyone can join the network as a storage provider and be compensated.
	\item Clients can upload files to the network, but do not need to remain online to submit proof of storage challenges to storage providers.
	\item Storage providers will suffer a financial penalty for losing a file, even if the client is not online to submit storage challenges.
	\item Storage providers will be compensated for successfully storing a file, regardless of client behavior.
	\item Clients can achieve high file reliability, even when the average storage provider is not reliable.
\end{itemize}

We have chosen to use a blockchain similar to Bitcoin \cite{btc, btcdg} as the foundation for our platform.
This is accomplished by adding a smart contract transaction type to the blockchain.
With this contract, a storage provider agrees to store a file for a period of time, submitting publicly auditable proofs of storage at some frequency.
Failure to submit a proof of storage results in a penalty for the storage provider, but succeeding results in compensation.
Global consensus combined with publicly auditable proofs of starge are used to enforce the contracts between clients and hosts.

The initial implementation of our decentralized storage platform will be a blockchain with an altcoin.
Future support for a two way peg with Bitcoin is planned, as discussed in ``Enabling Blockchain Innovations with Pegged Sidechains'' \cite{side}.
Our blockchain mimics the Bitcoin blockchain except for the changes noted below.

\section{General Structure}
The general rules for mining blocks, choosing forks, etc. will be the same as Bitcoin.
Sia's primary departure from Bitcoin lies in its transactions.
Bitcoin uses a scripting system to enable a range of transaction types, such as pay-to-public-key-hash and pay-to-script-hash.
Sia opts instead to use an $M$ of $N$ multi-signature hash scheme for all transactions.
This reduces complexity and attack surface.

Sia further extends transactions to enable file storage on the network.
Two extensions are needed to accomplish this: file contracts and storage proofs.
File contracts declare the intention of a storage provider to store a file with a certain size and hash.
They specify that a provider must periodically prove that they are still storing the file.
Providers accomplish this by submitting storage proofs to the network.
The specifics of this arrangement are defined in sections \ref{sec:contracts} and \ref{sec:storage}, respectively.

\section{Transactions}
A transaction contains the following fields:
\begin{tabular}{| l | l |}
	\hline
	\textbf{Field} & \textbf{Description} \\ \hline
	Version        & Protocol version number \\ \hline
	Arbitrary Data & Used for metadata or otherwise \\ \hline
	Miner Fee      & A fee for the miner \\ \hline
	Input List     & Incoming funds \\ \hline
	Output List    & Outgoing funds (optional) \\ \hline
	File Contract  & See: File Contracts (optional) \\ \hline
	Storage Proof  & See: Proof of Storage (optional) \\ \hline
	Signatures     & Signatures from each input \\ \hline
\end{tabular}

\subsection{Inputs}
Each input comprises a previous output ID and the spend conditions associated with that output.

\subsection{Outputs}
Each output holds an amount to be sent, along with a hash of the output spend conditions.
Each output has an associated identifier, which is derived from the transaction that the output appeared in.
The ID of output $i$ is defined as $H(\text{transaction containing output} || "coinsend" || i)$,
where input$_0$ is the ID of the first transaction input and $H$ is a cryptographic hashing function.

The miner subsidy and fees each block are given output ID = $H(H(Block Header) || "blockreward")$.

\subsection{Spend Conditions}
Outputs have a list of spend conditions which must be met before the coins are 'unlocked' and can be spent.
The spend conditions include a timelock and a set of public keys, and an integer indicating how many public keys must be signed to unlock the coins.
The output cannot be spent until the timelock has been expired.

The spend conditions are wrapped up into a merkle tree, with the leaves being the timelock, the number of signatures required, and each public key.
The root hash of the merkle tree is used as the 'address' to which the coins are spent.
When the coins are being spent, the spend conditions that match the address must be included along with the signatures.
We have chosen to make the spend conditions a merkle tree so that selective information can be revealed.
For example, the timelock can be revealed without revealing the number of public keys or the number of signatures required.

\subsection{Signatures}
Each cryptographic signature is paired with an input ID, a time lock, and a field indicating which parts of the transaction have been signed.
The input ID indicates which input in the transaction the signature is being applied to.
The signature cannot be used until the timelock has expired.
Any subset of fields in the transaction can be signed, including other signatures. (The arbitrary data, the miner fees, the inputs, the outputs, the contracts, the storage proofs, and the other signatures).
There is also a flag to indicate that the whole transaction should be signed, except for other signatures.
This allows for more nuanced transaction schemes.

The actual data being signed, then, is a concatenation of the time lock, input ID, bit array, and every field specified by the bit array.
Every such signature in the transaction must be valid for the transaction to be accepted.

\section{File Contracts}
\label{sec:contracts}
A file contract is an agreement between a storage provider and a client requiring the provider to store a certain file.
At the core of a file contract is the file's Merkle root hash \cite{merkle}.
This hash, along with the total size of the file, can be used to verify storage proofs.

File contracts also specify a duration, challenge frequency, and payout parameters, including the reward for a valid proof, the reward for an invalid or missing proof, and the maximum number of proofs that can be missed.
The challenge frequency determines the size of the window in which storage proofs can be submitted.
As soon as one challenge window closes, the next opens.
If a storage proof appears during the challenge window, an output is created sending coins to the valid proof addressi (presumably the host)
If no valid proof appears during the challenge winodw, an output is created sending coins to the missed proof address (either the client, or perhaps the '0' address, which cannot be spent).

A contract becomes invalid if a threshold of missed proofs is reached.
If the file contract is still valid at the end of the specified duration, it ``successfully terminates.''
Conversely, if the contract funds are exhausted before the duration elapses, or if the maximum number of missed proofs is exceeded, the contract ``unsuccessfully terminates.''
Each of these potential outcomes (valid proof, invalid proof, successful termination, unsuccessful termination) has an associated recipient.
The funds for these various payouts are provided by the inputs to the transaction.

The rewards for completed proofs and missed proofs create a new transaction output belonging to the recipient specified in the contract.
The recipient will be a hash of the output spend conditions for the new output.
The ID of a contract is defined by $H(\text{transaction} || "contract" || i)$, where ``contract'' is the string ``contract'', and $i$ is the index of the contract within the transaction.
The output ID of a storage proof is defined as $H(\text{contractID} || \text{outcome} || \text{window index})$.
The outcome has four possible values, corresponding to the four potential outcomes listed above.
The index is the index of the window which resulted in the creation of the output.
For example, the output created in the first window will have index 0.

\section{Proof of Storage}
\label{sec:storage}
Storage proof transactions are periodically submitted in order to fulfill file contracts.
Each storage proof targets a specific file.
A storage proof does not need to have any inputs or outputs; only a contract ID and the proof data are required.

\subsection{Algorithm}
Each contract has a challenge frequency, which requires the storage provider to submit a storage proof every $N$ blocks.
Each interval of $N$ blocks then constitutes a ``window'' in which to submit the proof.
The first such window, $W_0$, begins at a time which is specified in the contract.
Contracts can be submitted to the blockchain before the first window begins, which will lock down the funds and guarantee enforcement of the contract.

The storage challenge requires a random number as a seed.
The random number for window $W_i$ is generated by concatenating contract ID to the hash of the block prior to $W_i$ (i.e. $W_i + i \times N - 1$) and hashing the result.
This seed is used to select one of the file segments used as a leaf when creating the merkle tree of the file.
The provider supplies this segment data, along with the set of hashes that can be used to reconstruct the root of the tree.
The verifier can use these hashes to verify that the segment provided is indeed part of the original file.
Because the proofs are submitted to the blockchain, everyone can verify that the provider has provided the correct random segment.

% Need to find a reference to some literature explaining how merkle proofs work.

If the provider is consistently able to demonstrate possession of a random segment, then the provider is very likely storing the whole file.
A provider storing only 50\% of the file will be unable to complete approximately 50\% of the proofs.

\subsection{Random Number Generation}
The random number generator is subject to manipulation via block withholding attacks.
Because the random number is derived from a specific block, an attacker has only one chance to manipulate the random number for a particular challenge.
Furthermore, withholding a block to manipulate the random number will cost the attacker the block reward.

If an attacker is able to mine 50\% of the blocks, then 50\% of the challenges can be manipulated.
However, the remaining 50\% are still random, so even in this scenario, an attacker storing only 50\% of a file will still fail 25\% of its storage proofs.
Clients can therefore protect themselves against random number attacks by having many challenges and large penalites for missing proofs.
Assuming the attacker is financially motivated, large windows and severe penalties should be sufficient to deter any attacker that controls less than 50\% of the network's hashing power.
Clients are nonetheless advised to plan around potential Byzantine attacks which may not be financially motivated.

\subsection{Closed Window Attacks}
Storage providers can only complete a proof of storage if they can get a transaction with the storage proof into the blockchain.
Miners could maliciously exclude storage proofs from blocks, depriving themselves of transactions fees but forcing a penalty on storage providers.
We call this a 'closed window' attack, because though the storage provider has created a storage proof within the required window of time, they are unable to get the proof onto the blockchain.

The defense for this is having large windows, and assuming that at least some percentage of miners will be content submitting the storage proof in a block in return for a transaction fee.
Because providers consent to all file contracts, the storage provider is able to reject any contract that they feel leaves them vulnerable to closed window attacks.

\section{Arbitrary Transaction Data}
Each transaction has an arbitrary data field which can be used for any type of information.
Nodes will be required to store the arbitrary data if there is a signature in the transaction which includes the arbitary data in the signed fields.
Miners will initially accept up to 16kb of arbitrary data per block.
The reference node (non-mining) will accept any volume of arbitrary data, which allows soft-forks in the future to adjust how much arbitrary data is allowed.

The arbitrary data provides storage providers and clients a decentralized way to organize themselves.
Standards can be agreed upon that are used to announce providers, announce files, or create an entire decentralized file tracker.

It is possible that arbitrary data could be used for other types of soft forks, by creating an 'anyone can spend (0 sigs required)' output but then adding arbitrary data that the miners recognize as a new set of conditions on the output.
The miners block any transaction that spends the output without also satisfying the stipulations placed in the arbitrary data.
Old nodes will stay synchronized without needing to be able to parse the arbitrary data.

\section{Storage Ecosystem}
Sia relies on an ecosystem that facilitates decentralized storage.
Storage providers can use the arbitrary data field to announce themselves as providers to the network.
This can be done using standardized template that clients will be able to read.
Clients can read these announcements and create a database of providers.
They can then determine a set of providers that they trust (as a set) and create file contracts with those providers.
Storage providers and clients can then create micropayment channels \cite{mpc} which can be used to negotiate downloading the file.

\subsection{Storage Provider Protections}
A contract requires consent from both the storage provider and the client, allowing the provider to reject unfavorable terms and illegal files.
The provider additionally does not need to sign a contract until the full file has been uploaded.
The contract terms give storage providers flexibility.
They can advertise themselves as minimally reliable, offering a low price and a agreeing to minimal penalties for losing files.
Or, they can advertise themselves as highly reliable, offering a higher price and agreeing to high penalties for losing files.
An efficient market will optimize storage strategies.

Storage providers are potentially vulnerable to denial of service attacks, which could prevent the provider from giving storage proofs to the network, or prevent the provider from uploading a file to the client.
The storage providers themselves must take responsibility for protecting themselves, and must make sure that the penalties they agree to pay for missing storage proofs do not incentivize DoS attacks against the provider.

\subsection{Client Protections}
Clients can use erasure coding such as regenerating codes \cite{reg} codes to split files up into many pieces, of which only some need to be recovered.
Each piece is then encrypted and stored on many storage providers.
By encrypting the pieces after encoding them, the client ensures that collaborating providers are unable to reduce the redundancy.

Even if the average network reliability is very low, the client can maximize the reliability of its files by putting the files on many providers.
By only needing 10\% out of 100 providers, the client is relying on the most reliable 10\% of the 100, instead of the average reliability or least reliable subset.
If the client is able to restore lost pieces on occasion, reliability goes up even more.

By putting a file in many places, the client also benefits from an increased number of sources from which it can download data.
By only needing to connect to the closet 10\%, the client can reduce latency.
By only needing to connect to the fastest 10\%, the client can increase throughput.

Finally, this strategy also protects the client from malicious storage providers.
A storage provider that is demanding ransom for a file is the same to the client as a provider that is offline.
As long as 10\% of the providers are not acting maliciously, the client can retrieve the file.

\subsection{Uptime Incentives}
The storage proofs contain no provisions that require constant uptime.
There are also no provisions that require storage providers to upload files to clients upon request.

However, providers and clients can create micropayment channels to facilitate downloads.
If the client is offering a nontrivial fee for downloading a file, providers will be incentivized to collect the fee.
If one provider is unavailable or expensive, the client will pay the fee to a provider that is available and reasonably priced.
Providers are then incentivized to be online all the time, so that they can collect the bandwidth fees from clients.
If clients behaviorally pay providers well, then providers are more heavily incentivized to be online all the time.
Clients can also more heavily reward greater throughput and lower latency.
Clients could even do random "checkups" that pay providers some nontrivial reward simply for being online, even if they do not wish to download anything.
This further incentivizes providers to be online and available.
However, we reiterate that uptime incentives are not part of the Sia protocol; they are entirely dependent on client behavior.

\subsection{Basic Reputation System}
Clients need a reliable method for picking storage providers.
Hosts could potentially Sybil attack the network, and use false files to build up a fake reputation.
One defense for a Sybil attack would be for clients to only consider hosts that have X coin-days locked in an unspendable output.

Storage providers declare themselves using the arbitrary data in a transaction that creates a large timelocked output.
The timelocked output represents a commitment on the part of the storage provider to be reliable and inhibits the ability of malicious providers to perform Sybil attacks, as they will need large timelocked outputs.
When clients are scanning the blockchain, they select providers at random, but weight them according to the number of coins that are timelocked for more than a certain period of time.
Clients can also weight providers according to the size of the refund for losing files, and the price of the files.
Choosing a careful scheme for weighting providers during random selection will protect clients and ensure that malicious providers need to make significant investment to maintain a majority weight during the selection process.

This scheme does not leave clients any way to leave reviews for storage providers.
Additionally complexity could potentially allow clients to rate providers based on throughput, latency, and availability.
Such a review system would need careful design to prevent malicious providers from creating fake clients and files to boost their ratings.
A centralized storage tracker could provide a more reasonable environment for a reputation system, and could manage the whole system out of band.

\section{Siafunds}
Sia is a product released by Nebulous Incorporated.
Nebulous is a for profit company, and Sia is meant to be a primary source of income for the company.
Currency premining is not a stable source of income, as it requires creating a new currency, and tethering the company to the new currency's increasing value.
When the company needs to spend money, it must trade away portions of its source of income.
Additionally, premining means that one entity has control over a large volume of the currency, and therefore potentially large and disruptive control over the market.
This seems like a less than ideal way of doing things.

Instead, Nebulous pulls an income from Sia that is directly related to the value added by Sia, which is meaured by the value of the contracts set up between clients and hosts.
This is essentially a fee established on creating contracts.
When a contract is created, 10\% of the contract fund is set aside and distributed to the holders of siafunds.
Nebulous Inc. will initially hold ~95\% of the siafunds, and the early crowd-fund backers of Sia will hold the remaining ~5\%.

Every 4000 blocks, there will be a 'payday', where all of the funds set aside for the siafunds holders will be turned into unspent outputs that are valid on the network.
To limit the amount of bloat that this can cause, siafunds will be composed of 25,000 indivisible units, meaning that at most 25,000 outputs can be created per 4000 blocks as a result of siafunds.
Multiple siafunds in the same address will only result in 1 output.
As Nebulous will be holding ~23,740 sianotes, early on a maximum of ~1261 outputs per 4000 blocks will be created.
Furthermore, these outputs are implicit, meaning they only consume space on disk, and do not contribute to network bandwidth.
An output is merely a 64bit unsigned int and a 32 byte hash, for a total of 40 bytes each, or ~50kb per 4000 blocks.

Sianotes can be sent to other addresses, in the same way that siacoins can be sent to other addresses.
Sianotes cannot however be used to fund contracts or as a miner fee.

\subsection{Fee Exemption}
High reliability hosts are penalized by the 10\% fee on the contract fund.
If a host wishes to promise a 10x or 100x payout for losing a file, then the 10\% fee will greatly exceed the actual cost of the contract.
We wish to provide hosts with an avenue for dodging the fees on penalities, without giving clients a way to dodge the fees.
Any of the contract outputs that go to a null address (to an address that cannot be spent) will dodge the fees.
High reliability hosts can send funds for missing proofs to the 0 address, which means the client is not compensated, but the host is still penalized, and the fees are not severe.

\section{Economics of Sia}
Sia is going to be a permanently inflationary currency.
The inflation will be to the tune of 2\% annually.
There will initially be 1000 coins released every block, and this will continue until 1000 coins per block matches 2\% annual inflation.
Then, the number of coins released every block will be increased slightly every 20,000 blocks to maintain a 2\% annual inflation.

Coins must be locked down when creating contracts.
A contract lasting 1 month will have a months worth of coins in a spent output that are not in circulation.
The number of coins locked down will be even greater if the host is offering a large refund for losing the file.
As Sia's usage as a storage platform goes up, the scarcity of the coin will also go up.

Hosts are only dependent on the stability of the value of the siacoin for the duration of their contracts.
Hosts can continually reprice contracts as the sianote shifts in value.
Siacoins also derive value from the fact that you must have siacoins in order to create a contract.

\section{Under Consideration}
The primary foundation of Sia has been established above.
Other considerations, such as mining algorithm, block time, etc., can be assumed to mirror the settings found in Bitcoin.

Giving careful attention to ``A Treatise on Altcoins'' \cite{alts}, we are considering the following changes to Sia for the overall improvement of the cryptocurrency.
We caution that these propositions have not yet been rigorously examined from a security standpoint.

\subsection{Flexible Contracts}
Contracts are currently strict.
There is a set penalty for each missed storage proof, and a termination upon N total missed storage proofs.
Increased flexibility in the penalty schedule may be desirable.

Contracts are also currently permanent, creating what is essentially an uneditable file on the network.
There may be value in adding flexibility that allows clients and hosts to negotiate an updated file hash or other updated contract terms.
Updating the terms of the contract will require consent from all parties.

% \subsection{Proof of Existence Windows}
% In an attempt to partially resolve the closed window attacks, we could use a proof of existence strategy.
% A host can create a hash of the storage proof which they submit to the blockchain within the window.
% The host then has a greatly extended window in which they can demonstrate that the proof of storage was created during the required window.

% This has two advantages.
% First, an attacker cannot selectively exclude proof of existence hashes, because there's no way to figure out who owns each hash.
% Either the attacker doesn't include any unknown proof of existence hashes, or the attacker risks including undesired proof of existence hashes.
% Second, this allows hosts to submit small transactions to the network during peak hours and then the larger transactions when the traffic has died down.

% A further improvement would enable Merkle Tree proofs of existence.
% This would enable a host to submit multiple proofs of storage in a single proof of existence hash.

\subsection{Siafund the Miner fees}
Have some portion of siafunds contribute to the miner fees, which ensures that miners have compensation so long as Sia is being used for its core purpose - storage.

\subsection{Miner Fee Adjustments}
If a block has miner fees which are significantly higher than the fees in the current block, there is incentive for miners to re-mine the previous block and change who gets the miner fees.
This can be mitigated by putting all of the fees into a pool which pays out 50\% every block, making re-mining unprofitable for any party with less than 50\% of the network hashing power.
% Link to discussion threads of this potential change.

Additionally, miners have incentives not to propagate high fee transactions, because this will prevent other miners from mining the transaction and collecting the fees.
It may be possible to construct a system using fee deterioration that means a miner has the highest expected total reward when the transaction is mined as soon as possible - regardless of who mines the transaction.
% Link to discussion threads of this potential change.

\subsection{More Frequent Difficulty Adjustments}
We would wish to preserve the maximum difficulty adjustment of 4x every 2 weeks, however we would like to have more frequent difficulty adjustments.

Adjusting the difficulty every block solves the following issues:
\begin{itemize}
	\item Stronger defense against difficulty raising attacks, as difficulty raising must be staggered instead of jumping.
	\item Stronger defense against the timewarp attack.
	\item Smoother difficulty curve means less minining equipment being turned off simultaneously.
\end{itemize}
% Link to discussion threads for this potential change.

% \subsection{Committing to State}
% One thing that could allow for substantially lighter weight clients is if the miners committed to the current state of the network, instead of just to the new transactions.
% This would mean creating a structure for a database that represents the state of the network and hashing it.
% We could follow suggestions similar to those presented in ``Ultimate blockchain compression'' \cite{ubc}.

% \subsection{Variance Enforced Merge Mining}
% Bitcoin enforces a number of leading 0s on a winning block.
% Sia could enforce something like a single leading 1, followed by a bunch of leading 0s.
% This creates the property that no hash is ever valid for both Bitcoin and Sia.

% The value to this is that the number of payouts a miner gets from finding blocks goes up.
% The total payout is still the same, but the number of payouts increases by the number of blocks that would have been valid for both.
% A block that solves the coin with the highest difficulty will always be valid for both blockchains.
% (I need to read more about merge mining before I publish this section)

\section{Conclusion}
Sia takes the Bitcoin blockchain and modifies it to include file contracts and remove the scripting system.
These contracts can be used to enforce agreements between clients and hosts that establish a host will store a file in return for monetary compensation.
The host will be compensated for storing the file regardless of the behavior of the client.
The storage proof challenges are presented to the hosts on a regular basis and do not require interaction from the client, which means the client can ``set and forget''.

While these contracts force a host to store a file and be online regularly, these contracts do not force hosts to give up the file.
Instead, an out-of-band ecosystem is created which rewards hosts for being available and uploading the files upon request.
Clients and hosts can use the arbitrary data fields in the blockchain as an expensive mechanism for coordinating, or the clients and hosts can use entirely out-of-band methods for coordinating.
A basic system has been explained which provides moderate protection against sybil attacks and the general unreliability of hosts.

Siafunds are used as a mechanism of generating revenue for Nebulous Inc., the company responsible for the release of Sia.
By using Siafunds instead of premining, Nebulous more directly correlates revenue to actual use of the network, and is largely unaffected by market games that malicious entities may play with the network currency.
Miners may also derive a part of their block subsidy from Siafunds, which would help to insulate miners from market games as well.
Long term, we hope to add support for two-way-pegs with various currencies, which would enable consumers to insulate themselves from the instability of a single currency.

The Siacoin as a currency is a permanently inflationary currency, with 1000 coins being generated per block, forever.
There is a consideration to have the minimum annual inflation set to 2\%, which would provide miners with a proportional permanent source of income regardless of the size of transaction fees.

Experimental changes have also been proposed to the way mining fees are distributed, and to provide miners with an incentive to propagate transactions.
Changing the difficulty every block instead of every 2016 blocks provides a more consistent block time and a more tapered shutting down of obsolete mining hardware.

Altogether, we believe Sia will provide a fertile platform for decentralizing cloud storage in minimal trust and zero trust environments.

\onecolumn
\begin{thebibliography}{9}

\bibitem{btc}
	Satoshi Nakamoto,
	\emph{Bitcoin: A Peer-to-Peer Electronic Cash System}.

\bibitem{merkle}
	R.C. Merkle,
	\emph{Protocols for public key cryptosystems},
	In Proc. 1980 Symposium on Security and	Privacy,
	IEEE Computer Society, pages 122-133, April 1980.

\bibitem{cpr}
	Hovav Shacham, Brent Waters,
	\emph{Compact Proofs of Retrievability},
	Proc. of Asiacrypt 2008, vol. 5350, Dec 2008, pp. 90-107.

\bibitem{reg}
	K. V. Rashmi, Nihar B. Shah, and P. Vijay Kumar,
	\emph{Optimal Exact-Regenerating Codes for Distributed Storage at the MSR and MBR Points via a Product-Matrix Construction}.

\bibitem{side}
	Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller, Andrew Peolstra, Jorge Timon, Pieter Wuille,
	\emph{Enabling Blockchain Innovations with Pegged Sidechains}.

\bibitem{alts}
	Andrew Poelstra,
	\emph{A Treatise on Altcoins}.

\bibitem{ibf}
	Gavin Andresen,
	\emph{O(1) Block Propagation},
	https://gist.github.com/gavinandresen/e20c3b5a1d4b97f79ac2

\bibitem{hdw}
	Gregory Maxwell,
	\emph{Deterministic Wallets},
	https://bitcointalk.org/index.php?topic=19137.0

\bibitem{ubc}
	etotheipi,
	Ultimate blockchain compression w/ trust-free lite nodes, \newline
	https://bitcointalk.org/index.php?topic=88208.0

\bibitem{poc}
	Gregory Maxwell,
	\emph{Proof of Storage to make distributed resource consumption costly.}
	https://bitcointalk.org/index.php?topic=310323.0

\bibitem{mpc}
	Mike Hearn,
	\emph{Rapidly-adjusted (micro)payments to a pre-determined party},\newline
	https://en.bitcoin.it/wiki/Contracts\#Example\_7:\_Rapidly-adjusted\_.28micro.29payments\_to\_a\_pre-determined\_party

\bibitem{btcdg}
	Bitcoin Developer Guide
	https://bitcoin.org/en/developer-guide


\end{thebibliography}

\end{document}
