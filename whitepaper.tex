\documentclass[twocolumn]{article}
\usepackage{amsmath}

\begin{document}
\frenchspacing

\title{Sia: Simple Decentralized Storage}

\author{
{\rm David Vorick}\\
Nebulous Inc.\\
david@nebulouslabs.com
\and
{\rm Luke Champine}\\
Nebulous Inc.\\
luke@nebulouslabs.com
}

\maketitle

\subsection*{Abstract}
Sia is a Bitcoin-based altcoin with added support for decentralized storage.
With the primary goal of security, very few changes have been made to the Bitcoin protocol, only what is absolutely necessary.
Additional changes have been suggested in the final section, but will not be used without serious consideration and peer review.

\section{Introduction}
We wish to create a decentralized cloud storage platform that has the ability to compete with existing solutions cloud storage, both at the p2p level and the enterprise level.
We use smart contracts and decentralized consensus as the foundation for our platform.
We start with a system very similar to Bitcoin \cite{btc,btcdg}, and add a self-enforcing contract that allows hosts to accept compensation for storing a file if they can regularly submit proof that they are storing the file.
The network automatically creates proof of storage challenges, allowing the client to 'set and forget'.

We have chosen to make an altcoin because we need a specific type of smart contract to scan the blockchain for storage proofs.
This is not possible within Bitcoin, so a more robust solution is needed.
Between the existing altcoins and the promise of sidechains, we nonetheless felt that building an altcoin provided the greatest potential for success.

\section{General Structure}
The general rules for mining blocks, handling orphan blocks, etc. on Sia will be the same as Bitcoin.
Sia's primary departure from Bitcoin lies in its transactions.
Bitcoin uses a scripting system to enable a range of transaction types, such as pay-to-public-key-hash and pay-to-script-hash.
Sia opts instead to use an $M$ of $N$ multi-signature hash scheme for all transactions.
This reduces complexity and attack surface.

Sia further extends transactions to enable file storage on the network.
Two extensions are needed to accomplish this: file contracts and storage proofs.
File contracts declare the intention of a host to store a file with a certain size and hash.
They specify that a host must periodically prove that they are still storing the file.
Hosts accomplish this by submitting storage proofs to the network.
The specifics of this arrangement are defined in sections \ref{sec:contracts} and \ref{sec:storage}, respectively.

\section{Transactions}
A transaction contains the following fields:
\begin{tabular}{| l | l |}
	\hline
	\textbf{Field} & \textbf{Description} \\ \hline
	Version        & Protocol version number \\ \hline
	Arbitrary Data & Used for metadata or otherwise \\ \hline
	Input List     & Incoming funds \\ \hline
	Output List    & Outgoing funds (optional) \\ \hline
	File Contract  & See: File Contracts (optional) \\ \hline
	Storage Proof  & See: Proof of Storage (optional) \\ \hline
	Signatures     & Signatures from each input \\ \hline
\end{tabular}

A more detailed breakdown of these fields follows.

\subsection{Inputs}
Each input comprises a previous output ID and the spend conditions associated with that output.

\subsection{Outputs}
Each output holds an amount to be sent, along with a hash of the output spend conditions.
The difference between the inputs and outputs is given as a transaction fee to the miner.

Each output has an associated identifier, which is derived from the transaction that the output appeared in.
The ID of output $i$ is defined as $H(\text{input}_0 || i)$,
where input$_0$ is the ID of the first transaction input and $H$ is a cryptographic hashing function.

\subsection{Spend Conditions}
Both inputs and outputs make use of spend conditions, which dictate the circumstances under which an output can be spent.
The two allowed conditions are a time lock (which locks the output until a certain time) and an $M$ of $N$ signature scheme.
In such a scheme, there are $N$ public keys on the ``whitelist''.
Some subset $M < N$ must sign the transaction in order to unlock the output. 

\subsection{Signatures}
Each cryptographic signature is paired with an input ID and a time lock. 
The input ID indicates which input the signature is being applied to.
It must match one of the inputs in the transaction.
The time lock prevents the signature from being used before a certain time.
A bit array is also provided with the signature, which marks which fields of the transaction were signed.
Any field in the transaction can be marked as signed, including any subset of inputs and outputs---except for the signatures themselves.
This allows for more nuanced transaction schemes.

The actual data being signed, then, is a concatenation of the time lock, input ID, bit array, and every field specified by the bit array.
Every such signature in the transaction must be valid for the transaction to be accepted.

\section{File Contracts}
\label{sec:contracts}
A file contract is an agreement between a host and an uploader that the host will store a file.
At the core of a file contract is the file's Merkle root hash, formed by splitting the file into segments and repeatedly concatenating and hashing them.
This root hash, along with the total number of segments, can be used to verify storage proofs.

File contracts also specify a duration, challenge frequency, and payout parameters, including the reward for a valid proof, the refund for an invalid or missing proof, and the maximum number of proofs that can be missed.
If the file contract is still valid at the end of the specified duration, it ``successfully terminates.''
Conversely, if the contract funds are exhausted before the duration elapses, or if the maximum number of missed proofs is exceeded, the contract ``unsuccessfully terminates.''
Each of these potential outcomes (valid proof, invalid proof, successful termination, unsuccessful termination) has an associated recipient.
The funds for these various payouts are provided by the inputs to the transaction.

The rewards for completed proofs and missed proofs create a new transaction output belonging to the recipient specified in the contract.
The recipient will be a hash of the output spend conditions for the new output.
The output ID is defined as $H(\text{input}_0 || \text{outcome} || \text{index})$.
The outcome has four possible values, corresponding to the four potential outcomes listed above.
The index is the number of times this outcome has occurred during the contract.
Terminations will always have an index of 0, as the contract can only terminate once.

% This section needs help.
The contract ID is defined as the hash of the transaction announcing the contract.
The contract must be funded by output 0, which must specify a null recipient.
(A null recipient is defined as having all zeros as the hash of its spend conditions.)

\section{Proof of Storage}
\label{sec:storage}
Storage proof transactions are periodically submitted in order to fulfill file contracts.
Each storage proof targets a specific file.
A storage proof does not need to have any inputs or outputs; only a contract ID and the proof data are required.

\subsection{Algorithm}
Each contract has a challenge frequency, which requires the host to submit a storage proof every $N$ blocks.
Each interval of $N$ blocks then constitutes a ``window'' in which to submit the proof.
The first such window, $W_0$, begins immediately after the block containing the contract.

The storage challenge requires a random number as a seed.
The random number for window $W_i$ is generated by concatenating contract ID with the block prior to $W_i$ (i.e. $W_0 + i \times N - 1$) and hashing the result.
This seed is used to select one of the file segments used to produce the Merkle tree.
The host supplies this segment data, along with the set of hashes that can be used to reconstruct the root of the tree.
The challenger can use these hashes to verify that the segment provided is indeed part of the original file.
If the host is consistently able to demonstrate possession of a random segment, then the host is very likely storing the whole file.
A host storing only 50\% of the file will be unable to complete approximately 50\% of the proofs.

\subsection{Random Number Generation}
The random number generator is subject to manipulation via block withholding attacks.
Because the random number is derived from a specific block, an attacker has only one chance to manipulate the random number for a particular challenge.
Furthermore, withholding a block to manipulate the random number will cost the attacker the block reward.

If an attacker is able to mine 50\% of the blocks, then 50\% of the challenges can be manipulated.
However, the remaining 50\% are still random, so even in this scenario, an attacker storing only 50\% of a file will still fail 25\% of its storage proofs.
Clients can therefore protect themselves against random number attacks by having very large penalties for missing proofs.
Assuming the attacker is financially motivated, large windows and severe penalties should be sufficient to deter any attacker that controls less than 50\% of the network's hashing power.
Clients are nonetheless advised to plan around potential Byzantine attacks which may not be financially motivated.

\subsection{Closed Window Attacks}
Hosts can only complete a proof of storage if they can get a transaction with the storage proof into the blockchain.
Miners could maliciously exclude storage proofs from blocks, depriving themselves of transactions fees but forcing a penalty the hosts.
We call this a 'closed window' attack, because though the host has created the storage proof within the required window of time, they were unable to get the proof onto the blockchain.

The defense for this is having large windows, and assuming that at least one miner will be content submitting the storage proof in a block in return for a transaction fee.
Because hosts consent to all file contracts, the host is able to reject any contract that they feel leaves them vulnerable to a closed window attack.

\section{Arbitrary Transaction Data}
The arbitrary data provides hosts and clients a decentralized way to organize themselves.
Standards can be agreed upon that are used to announce hosts, announce files, or create an entire decentralized file tracker.
At a minimum, we plan on using the arbitrary data to associate hosts with files that they store, so that hosts can announce themselves a build a reputation.

Lightweight nodes do not need to store the arbitrary data, but the data is likely to be valuable to clients.
Clients would potentially be willing to pay to download the data, which would incentive nodes to keep the data around.

\section{Storage Ecosystem}
Sia relies on an ecosystem that facilitates decentralized storage.
The arbitrary data field will be used by hosts to announce themselves to the network, potentially specifying price, messaging address, etc.

Clients will be able to parse this data and create a database of hosts that they recognize.
They can then figure out a set of hosts that they trust (as a set), and create file contracts with those hosts.

The typical file contract will have both the host and the client paying funds into the contract, which enables the contract to enforce a financial penalty on the host for losing data.
Hosts and clients can then create micropayment channels \cite{mpc} which can be used to negotiate downloading the file.

\subsection{Host Protections}
A host does not need to agree to a contract, and is therefore able to reject unfavorable terms and unfavorable or illegal files.
A host also does not need to sign a contract until the full file has been uploaded, which protects the host against malicious clients.

The host has great flexibility in providing storage.
The host can advertise itself as minimally reliable, and keep each file on only one hard drive in one network location.
This will allow the host to sell cheap storage, and clients will likely be content with contracts that have minimal repercussions for lost files.
The host can also advertise itself as highly reliable.
This will allow the host to charge heavily for storage, but clients will likely require contracts with severe repercussions for lost files.

\subsection{Client Protections}
Clients can use erasure coding such as regenerating codes \cite{reg} codes to split files up into many pieces, of which only some need to be recovered.
Each piece is then encrypted and stored on many hosts.
By encrypting the pieces after encoding them, the client ensures that collaborating hosts are unable to reduce the redundancy.

Even if the average network reliability is very low, the client can maximize the reliability of its files by putting the files on many hosts.
By only needing 10\% out of 100 hosts, the client is betting against the most reliable 10\%, instead of betting against the average reliability.
If the client is able to restore lost pieces on occasion, reliability goes up even more.

By putting a file in many places, the client also benefits from an increased number of sources from which it can download data.
By only needing to connect to the closet 10\%, the client can reduce latency.
By only needing to connect to the fastest 10\%, the client can increase throughput.

Finally, this strategy also protects the client from host malice.
A host that is demanding ransom for a file is the same to the client as a host that is inactive.
As long as 10\% of the hosts are not acting maliciously, the client can retrieve the file.

\subsection{Uptime Incentives}
The storage proofs contain no provisions that require constant uptime.
There are also no provisions that require hosts to upload files to clients upon request.

However, hosts and clients can create micropayment channels to facilitate downloads.
If the client is offering a nontrivial fee for downloading a file, hosts will be incentivized to collect the fee.
If one host is unavailable, the client will pay the fee to a host that is available.
Hosts are then incentivized to be online all the time, so that they can collect the bandwidth fees from clients.
If clients behaviorally pay hosts well, then hosts are more heavily incentivized to be online all the time.
Clients can also more heavily reward greater throughput and lower latency.
Clients could even do random "checkups" that pay hosts some nontrivial reward simply for being online, even if they do not wish to download anything.
This further incentivizes hosts to be online and available.
However, we reiterate that uptime incentives are not part of the Sia protocol; they are entirely dependent on client behavior.

% \section{Sianotes}
% \subsection{Taxing Contracts}
% \subsection{Avoiding Taxes}
% \subsection{Sianotes outputs}

% \section{Economics of Sia}
% \subsection{Sianotes, income, no premining}
% \subsection{Permanent inflation}
% \subsection{Locking Coins Down}

\section{Under Consideration}
The primary foundation of Sia has been established above.
Other considerations, such as mining algorithm, block time, etc., can be assumed to mirror the settings found in Bitcoin.

Giving careful attention to ``A Treatise on Altcoins'' \cite{alts}, we are considering the following changes to Sia for the overall improvement of the cryptocurrency.
We caution that these propositions have not yet been rigorously examined from a security standpoint.

\subsection{Flexible Contract Penalities}
Contracts are currently strict.
There is a set penalty for each missed storage proof, and a termination upon N total missed storage proofs.
Increased flexibility in the penalty schedule may be desirable.

\subsection{File Editing}
Contracts are currently permanent, creating what is essentially an uneditable file on the network.
It might be worth figuring out provisions that enable files to be edited or taken offline under certain contract terms.
These terms would likely require consent from both the uploader and downloader.

\subsection{Different Storage Proofs}
Solutions such as ``Compact Proofs of Retrievability'' \cite{cpr} offer a potentially superior way to verify that hosts are storing files.

\subsection{Reduced Block Time}
We are comfortable reducing the block time to 5 minutes, with the primary goal being to reduce the variance with which a miner receives payment.
A 5 minute block time makes the network more vulnerable to attack, but improvements in block technology such as invertible bloom filters \cite{ibf} are enabling faster block propagation times.
We believe that the risk induced by halving the block time is less than the benefit gained from the reduced incentive to join mining pools.

\subsection{More Frequent Difficulty and Subsidy Adjustments}
We would wish to preserve the maximum difficulty adjustment of 4x every 2 weeks, however we would like to have more frequent difficulty adjustments.
We would wish to have more frequent subsidy adjustments, which gives people a more continuous sense of the economic state and prevents moments where many miners turn off simultaneously.

%\subsection{Max Block Size Adjustment}
%Max block size will be initially set at 256kb and increased by 256kb every 3 months for 2 years.
%Then it will increase by 25\% anually.

%\subsection{Long Range Miner Fees}
%Miner fees would go into a pool that pays out some portion of itself every block, like 0.1\%.
%Fees included into a block would incentivize miners for many future blocks, and be diluted slowly.

\subsection{File Contract Fees}
Some percent, like 1\% of all coins paid into a file contract would be given to miners.
This guarantees that as long as Sia is being used for it's core purpose (storage), there will be mining incentive.

%\subsection{Permanent Inflation}
%Picking something like 2\% or 5\% permanent inflation of the siacoin will discourage speculation, and also ensure that there is always a mining incentive.
%Since Sia is still useful for storage, the discouraged speculation will not kill the coin.

\subsection{Committing to State}
One thing that could allow for substantially lighter weight clients is if the miners committed to the current state of the network, instead of just to the new transactions.
This would mean creating a structure for a database that represents the state of the network and hashing it.
We could follow suggestions similar to those presented in ``Ultimate blockchain compression'' \cite{ubc}.

%\subsection{Variance Enforced Merge Mining}
%Bitcoin enforces a number of leading 0s on a winning block.
%Sia could enforce something like a single leading 1, followed by a bunch of leading 0s.
%This creates the property that no hash is ever valid for both Bitcoin and Sia.

%The value to this is that the number of payouts a miner gets from finding blocks goes up.
%The total payout is still the same, but the number of payouts increases by the number of blocks that would have been valid for both.
%A block that solves the coin with the highest difficulty will always be valid for both blockchains.
%(I need to read more about merge mining before I publish this section)

%\subsection{Single Use Signatures}
%You submit a transaction with a 1-of-N multisig.
%Each public key would only be allowed to be used once though.
%This allows one address to be used for many transactions, without needing to reuse signatures.

%Using the concepts applied in HD Wallets \cite{hdw} might help achieve the same goal.
%Using something like a Merkle signature scheme might also help achieve this goal.

%\subsection{Alternate Mining Structure}
%Alternatives have been suggested that would address things like block withholding attacks.
%Additionally it might be useful to have a scheme where multiple miners get paid every block (this allows for high block time, but low block finding variance).

\section{Conclusion}
Sia takes the Bitcoin cryptocurrency and makes a few major changes.
The first is removing the scripting system and instead enforcing a multisig solution, to reduce complexity and attack surface.
The second is to introduce a file contract, which enables hosts to claim that they will store a file in return for compensation, and that they will pay a penalty for losing the file.
Finally, arbitrary data fields have been added to all transactions to enable coordination among decentralized storage providers, and among decentralized file sharing systems.

We have additionally proposed an array of potential changes that range from simple and probably safe to complex and probably unsafe.
We do intend to explore these proposed changes further and decide concretely on which ones are worth integrating into Sia.

\onecolumn
\begin{thebibliography}{9}

\bibitem{btc}
	Satoshi Nakamoto,
	\emph{Bitcoin: A Peer-to-Peer Electronic Cash System}.

\bibitem{cpr}
	Hovav Shacham, Brent Waters,
	\emph{Compact Proofs of Retrievability},
	Proc. of Asiacrypt 2008, vol. 5350, Dec 2008, pp. 90-107.

\bibitem{reg}
	K. V. Rashmi, Nihar B. Shah, and P. Vijay Kumar,
	\emph{Optimal Exact-Regenerating Codes for Distributed Storage at the MSR and MBR Points via a Product-Matrix Construction}.

\bibitem{alts}
	Andrew Poelstra,
	\emph{A Treatise on Altcoins}.

\bibitem{ibf}
	Gavin Andresen,
	\emph{O(1) Block Propagation},
	https://gist.github.com/gavinandresen/e20c3b5a1d4b97f79ac2

\bibitem{hdw}
	Gregory Maxwell,
	\emph{Deterministic Wallets},
	https://bitcointalk.org/index.php?topic=19137.0

\bibitem{ubc}
	etotheipi,
	Ultimate blockchain compression w/ trust-free lite nodes, \newline
	https://bitcointalk.org/index.php?topic=88208.0

\bibitem{mpc}
	Mike Hearn,
	\emph{Rapidly-adjusted (micro)payments to a pre-determined party},\newline
	https://en.bitcoin.it/wiki/Contracts\#Example\_7:\_Rapidly-adjusted\_.28micro.29payments\_to\_a\_pre-determined\_party

\bibitem{btcdg}
	Bitcoin Developer Guide
	https://bitcoin.org/en/developer-guide


\end{thebibliography}

\end{document}
